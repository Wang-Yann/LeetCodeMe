#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author        : Rock Wayne 
# @Created       : 2020-05-07 08:00:00
# @Last Modified : 2020-05-07 08:00:00
# @Mail          : lostlorder@gmail.com
# @Version       : alpha-1.0

"""
# 一个N x N的网格(grid) 代表了一块樱桃地，每个格子由以下三种数字的一种来表示： 
# 
#  
#  0 表示这个格子是空的，所以你可以穿过它。 
#  1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。 
#  -1 表示这个格子里有荆棘，挡着你的路。 
#  
# 
#  你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃： 
# 
#  
#  从位置 (0, 0) 出发，最后到达 (N-1, N-1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）； 
#  当到达 (N-1, N-1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子； 
#  当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为0）； 
#  如果在 (0, 0) 和 (N-1, N-1) 之间不存在一条可经过的路径，则没有任何一个樱桃能被摘到。 
#  
# 
#  示例 1: 
# 
#  
# 输入: grid =
# [[0, 1, -1],
#  [1, 0, -1],
#  [1, 1,  1]]
# 输出: 5
# 解释： 
# 玩家从（0,0）点出发，经过了向下走，向下走，向右走，向右走，到达了点(2, 2)。
# 在这趟单程中，总共摘到了4颗樱桃，矩阵变成了[[0,1,-1],[0,0,-1],[0,0,0]]。
# 接着，这名玩家向左走，向上走，向上走，向左走，返回了起始点，又摘到了1颗樱桃。
# 在旅程中，总共摘到了5颗樱桃，这是可以摘到的最大值了。
#  
# 
#  说明: 
# 
#  
#  grid 是一个 N * N 的二维数组，N的取值范围是1 <= N <= 50。 
#  每一个 grid[i][j] 都是集合 {-1, 0, 1}其中的一个数。 
#  可以保证起点 grid[0][0] 和终点 grid[N-1][N-1] 的值都不会是 -1。 
#  
#  Related Topics 动态规划

"""

import functools
from typing import List

import pytest


# leetcode submit region begin(Prohibit modification and deletion)
class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        """
        DP　自顶而下 GOOD
        https://leetcode-cn.com/problems/cherry-pickup/solution/zhai-ying-tao-by-leetcode/
        与其从左上角走到右下角，再从右下角走到左上角；不如直接考虑从左上角选两条路走到右下角。
        在走了 t 步之后，我们可能处于的位置 (r, c) 满足 r+c=t，所以如果我们在位置 (r1, c1) 和 (r2, c2) 有两个人，那么 r2=r1+c1-c2。
        这意味着 r1，c1，c2 唯一地决定了两个走了 t 步数的人。这个条件让我们能够很好地进行动态规划

        定义 dp[r1][c1][c2] 是两个人从 (r1, c1) 和 (r2, c2) 开始，朝着 (N-1, N-1) 所能摘到最多的樱桃数量，其中 r2=r1+c1-c2。
        如果 grid[r1][c1] 和 grid[r2][c2] 不是荆棘，那么 dp[r1][c1][c2] 的值是 (grid[r1][c1] + grid[r2][c2])，加上 dp[r1+1][c1][c2]，
        dp[r1][c1+1][c2]，dp[r1+1][c1][c2+1]，dp[r1][c1+1][c2+1] 的最大值。在 (r1, c1) == (r2, c2) 的情况下，我们要避免重复计数。

        """
        if not grid:
            return 0
        N = len(grid)

        @functools.lru_cache(None)
        def dp(r1, c1, c2):
            r2 = r1 + c1 - c2
            if (r1 == N or r2 == N or c1 == N or c2 == N or
                    grid[r1][c1] == -1 or grid[r2][c2] == -1):
                return float("-inf")
            elif r1 == c1 == N - 1:
                return grid[r1][c1]
            else:
                ans = grid[r1][c1]
                if c1 != c2:
                    ans += grid[r2][c2]
                ans += max(dp(r1, c1 + 1, c2 + 1), dp(r1 + 1, c1, c2 + 1),
                           dp(r1, c1 + 1, c2), dp(r1 + 1, c1, c2))
            return ans

        res = max(0, dp(0, 0, 0))
        # print(dp.cache_info(),dp.__wrapped__(1,1,1))
        return res


# leetcode submit region end(Prohibit modification and deletion)

@pytest.mark.parametrize("args,expected", [
    (
            [[0, 1, -1],
             [1, 0, -1],
             [1, 1, 1]], 5
    ),
    (

            [[0, 0, 1, 0, 0, 1, 0, 1, 1, -1, 0, 0, -1, -1, 0, 1, 1, -1, 0, -1],
             [1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0],
             [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, -1, 0, 1, 1, 0],
             [0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, -1, 1, 0, 0, 1, 0, 0, 1, 1],
             [-1, 0, -1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, -1, 1, 0, 0, 0, 1, 1],
             [0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0],
             [0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, -1, 1, 0, 1, 1, 0, 1, 1, 0],
             [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1],
             [0, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0],
             [1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, -1, 0, -1, 0, 1, 0],
             [0, 1, -1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, -1, 1, 0, 0, -1, 0],
             [0, 0, 0, 0, 1, 0, 1, 0, 0, -1, 0, 1, 0, -1, 0, 0, 1, 0, 1, 1],
             [1, -1, -1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0],
             [-1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0],
             [0, 1, -1, 1, 1, 1, 0, 0, 1, -1, 1, 1, 0, 1, 0, 1, 0, -1, 1, 0],
             [1, -1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, -1, 0, 0, 1, 0, -1],
             [-1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, -1, 0, 1, 0, 0, 1, 0],
             [0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1],
             [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1],
             [0, 0, 0, 1, -1, 0, -1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, -1, 0]], 52

    )
])
def test_solutions(args, expected):
    assert Solution().cherryPickup(args) == expected


if __name__ == '__main__':
    pytest.main(["-q", "--color=yes", "--capture=no", __file__])

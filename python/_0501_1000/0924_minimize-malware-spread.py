#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author        : Rock Wayne 
# @Created       : 2020-05-06 08:00:00
# @Last Modified : 2020-05-06 08:00:00
# @Mail          : lostlorder@gmail.com
# @Version       : alpha-1.0

"""
# 在节点网络中，只有当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j。 
# 
#  一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传
# 播将继续，直到没有更多的节点可以被这种方式感染。 
# 
#  假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。 
# 
#  我们可以从初始列表中删除一个节点。如果移除这一节点将最小化 M(initial)， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。 
# 
#  请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后可能仍然因恶意软件传播而受到感染。 
# 
#  
# 
#  
#  
# 
#  示例 1： 
# 
#  输入：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
# 输出：0
#  
# 
#  示例 2： 
# 
#  输入：graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
# 输出：0
#  
# 
#  示例 3： 
# 
#  输入：graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
# 输出：1
#  
# 
#  
# 
#  提示： 
# 
#  
#  1 < graph.length = graph[0].length <= 300 
#  0 <= graph[i][j] == graph[j][i] <= 1 
#  graph[i][i] == 1 
#  1 <= initial.length < graph.length 
#  0 <= initial[i] < graph.length 
#  
#  Related Topics 深度优先搜索 并查集

"""
import collections
from typing import List

import pytest


# leetcode submit region begin(Prohibit modification and deletion)


class UnionFind(object):

    def __init__(self, n):
        self.set = list(range(n))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x])  # path compression.
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = map(self.find_set, (x, y))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        return True


class Solution(object):

    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        """
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """
        union_find = UnionFind(len(graph))
        for i in range(len(graph)):
            for j in range(i + 1, len(graph)):
                if graph[i][j] == 1:
                    union_find.union_set(i, j)
        union_size = collections.Counter(union_find.find_set(i) for i in range(len(graph)))
        malware_count = collections.Counter(union_find.find_set(i) for i in initial)
        return min(initial, key=lambda x:[malware_count[union_find.find_set(x)] > 1, -union_size[union_find.find_set(x)], x])


# leetcode submit region end(Prohibit modification and deletion)
class Solution1:
    """
     连通分量
    https://leetcode-cn.com/problems/minimize-malware-spread/solution/jin-liang-jian-shao-e-yi-ruan-jian-de-chuan-bo-b-2/
    """

    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        # 1. Color each component.
        # colors[node] = the color of this node.
        N = len(graph)
        colors = {}
        c = 0

        def dfs(node, color):
            colors[node] = color
            for neighbor, adj in enumerate(graph[node]):
                if adj and neighbor not in colors:
                    dfs(neighbor, color)

        for node in range(N):
            if node not in colors:
                dfs(node, c)
                c += 1
        # 2. Size of each color.
        # size[color] = number of occurrences of this color.

        size = collections.Counter(colors.values())
        # 3. Find unique colors.
        color_cnt = collections.Counter()
        for node in initial:
            color_cnt[colors[node]] += 1

        # 4. Answer
        ans = float("inf")
        for x in initial:
            c = colors[x]
            if color_cnt[c] == 1:
                if ans == float("inf"):
                    ans = x
                elif size[c] > size[colors[ans]]:
                    ans = x
                elif size[c] == size[colors[ans]] and x < ans:
                    ans = x
        return ans if ans < float("inf") else min(initial)


@pytest.mark.parametrize("kwargs,expected", [
    (dict(
        graph=[[1, 1, 0], [1, 1, 0], [0, 0, 1]], initial=[0, 1]
    ), 0),
    pytest.param(dict(graph=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], initial=[0, 2]), 0),
    pytest.param(dict(graph=[[1, 1, 1], [1, 1, 1], [1, 1, 1]], initial=[1, 2]), 1),
])
def test_solutions(kwargs, expected):
    assert Solution().minMalwareSpread(**kwargs) == expected
    assert Solution1().minMalwareSpread(**kwargs) == expected


if __name__ == '__main__':
    pytest.main(["-q", "--color=yes", "--capture=no", __file__])

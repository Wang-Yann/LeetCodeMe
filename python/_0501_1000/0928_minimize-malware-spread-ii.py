#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Author        : Rock Wayne 
# @Created       : 2020-05-06 08:00:00
# @Last Modified : 2020-05-06 08:00:00
# @Mail          : lostlorder@gmail.com
# @Version       : alpha-1.0

"""
# (这个问题与 尽量减少恶意软件的传播 是一样的，不同之处用粗体表示。) 
# 
#  在节点网络中，只有当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j。 
# 
#  一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传
# 播将继续，直到没有更多的节点可以被这种方式感染。 
# 
#  假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。 
# 
#  我们可以从初始列表中删除一个节点，并完全移除该节点以及从该节点到任何其他节点的任何连接。如果移除这一节点将最小化 M(initial)， 则返回该节点。如
# 果有多个节点满足条件，就返回索引最小的节点。 
# 
#  
# 
#  
#  
# 
#  示例 1： 
# 
#  输出：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
# 输入：0
#  
# 
#  示例 2： 
# 
#  输入：graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
# 输出：1
#  
# 
#  示例 3： 
# 
#  输入：graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
# 输出：1
#  
# 
#  
# 
#  提示： 
# 
#  
#  1 < graph.length = graph[0].length <= 300 
#  0 <= graph[i][j] == graph[j][i] <= 1 
#  graph[i][i] = 1 
#  1 <= initial.length < graph.length 
#  0 <= initial[i] < graph.length 
#  
#  Related Topics 深度优先搜索 并查集 图

"""
import collections
from typing import List

import pytest


# leetcode submit region begin(Prohibit modification and deletion)
class Solution:

    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        N = len(graph)
        clean = set(range(N)) - set(initial)

        def dfs(u, seen):
            for v, adj in enumerate(graph[u]):
                if adj and v in clean and v not in seen:
                    seen.add(v)
                    dfs(v, seen)

        infected_by = collections.defaultdict(list)
        # For each node u in initial, dfs to find
        # 'seen': all nodes not in initial that it can reach.

        for u in initial:
            seen = set()
            dfs(u, seen)
            # For each node v that was seen, u infects v.
            for v in seen:
                infected_by[v].append(u)

        # For each node u in initial, for every v not in initial
        # that is uniquely infected by u, add 1 to the contribution for u.

        contributions = collections.Counter()
        for v, neighbors in infected_by.items():
            if len(neighbors) == 1:
                contributions[neighbors[0]] += 1

        best = (-1, min(initial))
        for u, score in contributions.items():
            if score > best[0] or score == best[0] and u < best[1]:
                best = score, u
        return best[1]


# leetcode submit region end(Prohibit modification and deletion)

class Solution1(object):
    """
    https://www.jiuzhang.com/solution/minimize-malware-spread-ii#tag-highlight-lang-python
    """

    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        d = collections.defaultdict(list)
        # 对每个初始感染节点依次bfs，因为节点总数不超过300，所以不会超时
        for init in initial:
            vis = set(initial)
            Q = collections.deque([init])
            while Q:
                infect = Q.popleft()
                for node in range(len(graph[infect])):
                    if graph[infect][node] == 0:
                        continue
                    if node in vis:
                        continue
                    vis.add(node)
                    d[node].append(init)
                    Q.append(node)
        # print(d )
        # 统计出现最多次的感染节点
        res = [0] * n
        for key in d:
            if len(d[key]) == 1:
                v = d[key][0]
                res[v] += 1
        if max(res) == 0:
            return min(initial)
        return res.index(max(res))


@pytest.mark.parametrize("kwargs,expected", [
    (dict(
        graph=[[1, 1, 0], [1, 1, 0], [0, 0, 1]], initial=[0, 1]
    ), 0),
    pytest.param(dict(graph=[[1, 1, 0], [1, 1, 1], [0, 1, 1]], initial=[0, 1]), 1),
    pytest.param(dict(graph=[[1, 1, 0, 0], [1, 1, 1, 0], [0, 1, 1, 1], [0, 0, 1, 1]], initial=[0, 1]), 1),
])
def test_solutions(kwargs, expected):
    assert Solution().minMalwareSpread(**kwargs) == expected
    assert Solution1().minMalwareSpread(**kwargs) == expected


if __name__ == '__main__':
    pytest.main(["-q", "--color=yes", "--capture=no", __file__])
